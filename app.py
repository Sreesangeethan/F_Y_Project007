# ============================================================================
#  Futuristic LMS – single-file Flask application (OpenAI pieces commented out)
#  Fully self-contained; relies only on llama-cpp for AI generation.
# ----------------------------------------------------------------------------
#  Key fixes vs. your previous version
#  ----------------------------------
#  • removed duplicate imports/definitions
#  • lazy-loads the Llama model instead of doing it at import time
#  • commented-out **all** OpenAI-specific code (imports, client, functions)
#  • keeps only one generate_* implementation (Llama-based)
#  • route names ↔ template names must match (use url_for('admin_dashboard') …)
#  • only one app.run(debug=True) at the bottom
# ============================================================================

from __future__ import annotations

# ----------------------------
# Standard-library imports
# ----------------------------
import os
from functools import wraps
from typing import Callable, Optional

# ----------------------------
# Third-party imports
# ----------------------------
import requests
from dotenv import load_dotenv
from flask import (
    Flask,
    flash,
    redirect,
    render_template,
    request,
    session,
    url_for,
)
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy.orm import relationship
from werkzeug.security import check_password_hash, generate_password_hash
from llama_cpp import Llama

# OpenAI support removed – uncomment if you ever need it again.
# import openai
# from openai import OpenAI

# ---------------------------------------------------------------------------
# Environment & configuration
# ---------------------------------------------------------------------------
load_dotenv()  # Reads .env into process env

BASE_DIR = os.path.abspath(os.path.dirname(__file__))
DATABASE_PATH = os.path.join(BASE_DIR, "lms_app.db")

app = Flask(__name__)
app.config.update(
    SECRET_KEY=os.environ.get("SECRET_KEY", "!!!_replace_me_in_prod_!!!"),
    SQLALCHEMY_DATABASE_URI=f"sqlite:///{DATABASE_PATH}",
    SQLALCHEMY_TRACK_MODIFICATIONS=False,
)

db = SQLAlchemy(app)

# ---------------------------------------------------------------------------
# Llama model – lazy loader so we don't burn RAM during every hot-reload
# ---------------------------------------------------------------------------

_LLM: Optional[Llama] = None
# ------------------------------------------------------------------
#  LLM loader
# ------------------------------------------------------------------
from llama_cpp import Llama

_LLM = None  # cache

def get_llm():
    """
    Lazily load the GGUF model and cache the Llama object.
    """
    global _LLM
    if _LLM is None:
        MODEL_PATH = (
            r"C:\Users\srees\Downloads\F_Y_Project 007\sange _ Final\Models"
            r"\llama-2-7b-chat.Q4_K_M.gguf"
        )
        _LLM = Llama(model_path=MODEL_PATH, n_ctx=2048)
    return _LLM
# ---------------------------------------------------------------------------
# Helper functions using Llama
# ---------------------------------------------------------------------------

# ----------------------------------------------------------------------
# LLaMA helpers – FIXED
# ----------------------------------------------------------------------
def generate_quiz_questions(content: str, num_questions: int = 5) -> str:
    """
    Return plain-text multiple-choice questions generated by the local LLaMA model.
    """
    prompt = f"""
You are an AI tutor. Based on the following content, generate {num_questions} multiple-choice quiz questions.
Each should have 4 options (A, B, C, D) and indicate the correct answer at the end.

Content:
{content}

Format:
1) Question text…
A) Option A
B) Option B
C) Option C
D) Option D
Correct answer: X
"""
    # llama_cpp returns a dict ➜ extract text first!
    raw = get_llm()(prompt=prompt, max_tokens=700)
    return raw["choices"][0]["text"].strip()


def generate_adaptive_response(content: str, student_question: str) -> str:
    """
    Return an explanation that answers *student_question* using *content*.
    """
    prompt = f"""
You are an AI tutor.  Explain clearly the answer to the student's question,
using only the course content provided.

Content:
{content}

Student's question: {student_question}

Answer:
"""
    raw = get_llm()(prompt=prompt, max_tokens=400)
    return raw["choices"][0]["text"].strip()
# ---------------------------------------------------------------------------
# Database models
# ---------------------------------------------------------------------------

class User(db.Model):
    __tablename__ = "users"
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(50), unique=True, nullable=False)
    password_hash = db.Column(db.String(128), nullable=False)
    role = db.Column(db.String(10), nullable=False)  # "admin" or "student"

    def check_password(self, password: str) -> bool:  # noqa: D401
        return check_password_hash(self.password_hash, password)


class Course(db.Model):
    __tablename__ = "courses"
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(100), nullable=False)
    description = db.Column(db.Text, nullable=False)
    modules = relationship("Module", backref="course", cascade="all, delete-orphan")


class Module(db.Model):
    __tablename__ = "modules"
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(100), nullable=False)
    content = db.Column(db.Text, nullable=False)
    course_id = db.Column(db.Integer, db.ForeignKey("courses.id"))


class QuizQuestion(db.Model):
    __tablename__ = "quiz_questions"
    id = db.Column(db.Integer, primary_key=True)
    question = db.Column(db.Text, nullable=False)
    options = db.Column(db.Text, nullable=False)  # pipe-separated list
    answer = db.Column(db.String(50), nullable=False)
    module_id = db.Column(db.Integer, db.ForeignKey("modules.id"))


class QuizAttempt(db.Model):
    __tablename__ = "quiz_attempts"
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey("users.id"))
    module_id = db.Column(db.Integer, db.ForeignKey("modules.id"))
    score = db.Column(db.Float, nullable=False)


# ---------------------------------------------------------------------------
# Auth decorators
# ---------------------------------------------------------------------------

def admin_required(view: Callable):
    @wraps(view)
    def wrapper(*args, **kwargs):
        if "user_id" not in session:
            flash("Please log in first.", "warning")
            return redirect(url_for("login"))
        user = User.query.get(session["user_id"])  # type: ignore[arg-type]
        if not user or user.role != "admin":
            flash("Admin rights required.", "danger")
            return redirect(url_for("index"))
        return view(*args, **kwargs)

    return wrapper


def student_required(view: Callable):
    @wraps(view)
    def wrapper(*args, **kwargs):
        if "user_id" not in session:
            flash("Please log in first.", "warning")
            return redirect(url_for("login"))
        user = User.query.get(session["user_id"])  # type: ignore[arg-type]
        if not user or user.role != "student":
            flash("Student account required.", "danger")
            return redirect(url_for("index"))
        return view(*args, **kwargs)

    return wrapper


# ---------------------------------------------------------------------------
# Routes – public / auth
# ---------------------------------------------------------------------------

@app.route("/")
def index():
    return render_template("index.html")


@app.route("/register", methods=["GET", "POST"])
def register():
    if request.method == "POST":
        username = request.form.get("username", "").strip()
        password = request.form.get("password", "")
        role = request.form.get("role", "student")

        if User.query.filter_by(username=username).first():
            flash("Username already taken.", "danger")
            return redirect(url_for("register"))

        new_user = User(
            username=username,
            password_hash=generate_password_hash(password),
            role=role,
        )
        db.session.add(new_user)
        db.session.commit()
        flash("Registration successful – please log in.", "success")
        return redirect(url_for("login"))

    return render_template("register.html")


@app.route("/login", methods=["GET", "POST"])
def login():
    if request.method == "POST":
        username = request.form.get("username", "")
        password = request.form.get("password", "")
        user = User.query.filter_by(username=username).first()
        if user and user.check_password(password):
            session["user_id"] = user.id
            session["role"] = user.role
            flash("Logged in successfully.", "success")
            return redirect(url_for("admin_dashboard" if user.role == "admin" else "student_dashboard"))
        flash("Invalid credentials.", "danger")
    return render_template("login.html")


@app.route("/logout")
def logout():
    session.clear()
    flash("Logged out.", "info")
    return redirect(url_for("index"))


# ---------------------------------------------------------------------------
# Routes – Admin
# ---------------------------------------------------------------------------

@app.route("/admin/dashboard")
@admin_required
def admin_dashboard():
    courses = Course.query.all()
    return render_template("admin_dashboard.html", courses=courses)


@app.route("/admin/create_course", methods=["GET", "POST"])
@admin_required
def create_course():
    if request.method == "POST":
        title = request.form.get("title", "Untitled course")
        description = request.form.get("description", "")
        db.session.add(Course(title=title, description=description))
        db.session.commit()
        flash("Course created!", "success")
        return redirect(url_for("admin_dashboard"))
    return render_template("create_course.html")


@app.route("/admin/course/<int:course_id>")
@admin_required
def admin_course_detail(course_id: int):
    course = Course.query.get_or_404(course_id)
    return render_template("admin_course_detail.html", course=course)


@app.route("/admin/create_module/<int:course_id>", methods=["GET", "POST"])
@admin_required
def create_module(course_id: int):
    course = Course.query.get_or_404(course_id)
    if request.method == "POST":
        title = request.form.get("title", "Untitled module")
        content = request.form.get("content", "")
        db.session.add(Module(title=title, content=content, course_id=course.id))
        db.session.commit()
        flash("Module created!", "success")
        return redirect(url_for("admin_course_detail", course_id=course.id))
    return render_template("create_module.html", course=course)


@app.route("/admin/generate_quiz/<int:module_id>")
@admin_required
def generate_quiz(module_id: int):
    module = Module.query.get_or_404(module_id)

    if QuizQuestion.query.filter_by(module_id=module.id).first():
        flash("Quiz already exists for this module.", "info")
        return redirect(url_for("admin_course_detail", course_id=module.course_id))

    raw_quiz = generate_quiz_questions(module.content, num_questions=5)

    # Naïve parser (same as before)
    question, options, answer = "", [], ""
    for line in raw_quiz.splitlines():
        line = line.strip()
        if line[:2] in {"1)", "2)", "3)", "4)", "5)"}:
            if question and options and answer:
                db.session.add(QuizQuestion(question=question, options="|".join(options), answer=answer, module_id=module.id))
            question, options, answer = line[2:].strip(), [], ""
        elif line[:2] in {"A)", "B)", "C)", "D)"}:
            options.append(line)
        elif line.lower().startswith("correct answer"):
            answer = line.split(":")[-1].strip()
    if question and options and answer:
        db.session.add(QuizQuestion(question=question, options="|".join(options), answer=answer, module_id=module.id))

    db.session.commit()
    flash("Quiz generated successfully!", "success")
    return redirect(url_for("admin_course_detail", course_id=module.course_id))


@app.route("/admin/analytics")
@admin_required
def analytics():
    data = []
    for m in Module.query.all():
        attempts = QuizAttempt.query.filter_by(module_id=m.id).all()
        if attempts:
            scores = [a.score for a in attempts]
            data.append({
                "title": m.title,
                "avg": round(sum(scores) / len(scores), 2),
                "max": max(scores),
                "min": min(scores),
                "count": len(scores),
            })
        else:
            data.append({"title": m.title, "avg": None, "max": None, "min": None, "count": 0})
    return render_template("analytics.html", module_data=data)


# ---------------------------------------------------------------------------
# Routes – Student
# ---------------------------------------------------------------------------

@app.route("/student/dashboard")
@student_required
def student_dashboard():
    courses = Course.query.all()
    return render_template("student_dashboard.html", courses=courses)


@app.route("/student/course/<int:course_id>")
@student_required
def student_course_detail(course_id: int):
    course = Course.query.get_or_404(course_id)
    return render_template("student_course_detail.html", course=course)


@app.route("/student/module/<int:module_id>", methods=["GET", "POST"])
@student_required
def student_module_detail(module_id: int):
    module = Module.query.get_or_404(module_id)
    answer: Optional[str] = None
    if request.method == "POST":
        q = request.form.get("student_question", "")
        answer = generate_adaptive_response(module.content, q)
    questions = QuizQuestion.query.filter_by(module_id=module.id).all()
    return render_template(
        "student_module_detail.html",
        module=module,
        quiz_questions=questions,
        adaptive_answer=answer,
    )


@app.route("/student/quiz/<int:module_id>", methods=["GET", "POST"])
@student_required
def student_quiz(module_id: int):
    module = Module.query.get_or_404(module_id)
    questions = QuizQuestion.query.filter_by(module_id=module.id).all()

    if request.method == "POST":
        correct = 0
        for q in questions:
            if request.form.get(f"question_{q.id}") == q.answer:
                correct += 1
        score = round((correct / len(questions)) * 100, 2) if questions else 0.0
        db.session.add(QuizAttempt(user_id=session["user_id"], module_id=module.id, score=score))
        db.session.commit()
        flash(f"You scored {score}%.", "info")
        return redirect(url_for("student_module_detail", module_id=module.id))

    return render_template("student_quiz.html", module=module, quiz_questions=questions)


# ---------------------------------------------------------------------------
# Moodle import helpers – unchanged except for imports cleanup
# ---------------------------------------------------------------------------

def import_modules_for_course(moodle_course_id: int, local_course: Course) -> int:
    moodle_url = os.environ.get("MOODLE_URL", "https://your-moodle.com")
    moodle_token = os.environ.get("MOODLE_TOKEN", "your_moodle_token")
    endpoint = f"{moodle_url}/webservice/rest/server.php"

    params = {
        "wstoken": moodle_token,
        "wsfunction": "core_course_get_contents",
        "moodlewsrestformat": "json",
        "courseid": moodle_course_id,
    }
    sections = requests.get(endpoint, params=params, timeout=30).json()

    added = 0
    for section in sections:
        for mod in section.get("modules", []):
            if Module.query.filter_by(title=mod.get("name"), course_id=local_course.id).first():
                continue
            db.session.add(Module(
                title=mod.get("name", "Untitled Module"),
                content=mod.get("description") or section.get("summary", ""),
                course_id=local_course.id,
            ))
            added += 1
    db.session.commit()
    return added


@app.route("/admin/moodle_import", methods=["GET", "POST"])
@admin_required
def moodle_import():
    if request.method == "POST":
        moodle_url = os.environ.get("MOODLE_URL")
        moodle_token = os.environ.get("MOODLE_TOKEN")
        if not (moodle_url and moodle_token):
            flash("Please set MOODLE_URL and MOODLE_TOKEN in your environment.", "danger")
            return redirect(url_for("admin_dashboard"))

        endpoint = f"{moodle_url}/webservice/rest/server.php"
        params = {"wstoken": moodle_token, "wsfunction": "core_course_get_courses", "moodlewsrestformat": "json"}
        moodle_courses = requests.get(endpoint, params=params, timeout=30).json()

        new_courses, new_modules = 0, 0
        for mc in moodle_courses:
            course = Course.query.filter_by(title=mc.get("fullname")).first()
            if not course:
                course = Course(title=mc.get("fullname"), description=mc.get("summary"))
                db.session.add(course)
                db.session.commit()
                new_courses += 1
            new_modules += import_modules_for_course(mc.get("id"), course)

        flash(f"Imported {new_courses} course(s) and {new_modules} module(s).", "success")
        return redirect(url_for("admin_dashboard"))

    return render_template("moodle_import.html")


# ---------------------------------------------------------------------------
# App entry-point – create DB then run
# ---------------------------------------------------------------------------

if __name__ == "__main__":
    with app.app_context():
        db.create_all()
    # Development server – use Gunicorn or uwsgi in production.
    app.run(debug=True)
